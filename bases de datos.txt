MF0966_3 - Consulta y manipulación de información contenida en gestores de datos


26/12/2019:
	- java 7 Autoclosable
		- intro
		- Antes de Java 7
		- Uso del ARM

	- Pool de conexiones
		se encarga de gestionar todas las conexiones a la base de datos, en lugar de estar estableciendo la conexión y errándola cada vez que queramos acceder
		- intro
		- problemas
		- pool de cxs
		- config (en connectionManager): DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/mydb"); //jdbc/mydb --> devuelve un dataSource


	- JDBC Presentación (power point)


-------------------------------------------------------------------


27/12/2019:

- ACID
	- Atomicidad: o se hacen todos los pasos o ninguno (si se saca dinero del banco para ingresar en otra cuenta y no se lleva a cabo, no se quedan las 2 cuentas sin el dinero). Commit y rollback
	- Consistencia: los datos no cambian
	- Aislamiento: una operación no puede afectar a otras. Dos personas no pueden modificar a la vez el mismo registro de la bd (SGBD: sistemas gestión bases de datos)
	- Durabilidad: la info no se pierde aunque se apague el ordenador


- Motores de almacenamiento de MySQL y tipos de tablas
	- INNODB y MyISAM son las más usadas


-------------------------------------------------------------------


30/12/2019:

- JOINs combinar varias tablas
	- normalmente usamos inner join
	- RIGHT muestra aunque no tenga viviendas // LEFT es como la inner normal (posible test)
	- Equi-join --> 
		SELECT *
 		FROM   empleado
        	INNER JOIN departamento ON empleado.IDDepartamento = departamento.IDDepartamento
	- Natural join: no vamos a usar

	- Combinación externa (OUTER JOIN)
		- LEFT (dando la vuelta a las tablas una right se puede convertir en una left)
		- LEFT JOIN excluyendo la intersección

- Normalización de un Base de Datos (pdf)
	- "...en el código PHP ...  preparado para comenzar a desarrollar tu aplicación en PHP (sustituir php por java)"
	- BD relacional: tablas que se relacionan entre otras y se pueden sacar datos relacionados de varias
	- quitar duplicados --> conseguimos consistencia
	- Primer nivel de Formalización/Normalización. (F/N)
		1. Eliminar los grupos repetitivos de la tablas individuales.
		2. Crear una tabla separada por cada grupo de datos relacionados.
		3. Identificar cada grupo de datos relacionados con una clave primaria. 
	- Segundo nivel de F/N (tabla auxiliar)
		1. Crear tablas separadas para aquellos grupos de datos que se aplican a varios registros.
		2. Relacionar estas tablas mediante una clave externa. 
	- Tercer nivel de F/N.
		1. Eliminar aquellos campos que no dependan de la clave. --> toda info redundante la sacamos a otra tabla
	- Cuarto Nivel de F/N.
		1. En las relaciones varios-con-varios, entidades independientes no pueden ser almacenadas en la misma tabla. 
		--> si la relación es N a N, sacamos una tabla nueva
	- Quinto Nivel de F/N
		1. La tabla original debe ser reconstruida desde las tablas resultantes en las cuales ha sido troceada. 

- Hacemos un test de 20 preguntas con lo que hemos dado hasta aquí


-------------------------------------------------------------------


08/01/2020:


- Procedimientos almacenados. Procedimientos y Funciones
	- creamos tabla categorías y procedimiento con Heidi


		CONSULTA INSERT HEIDI
		-- declaramos una variable usando @
		SET @id_generado = 0;

		-- llamamos al procedimiento almacenado
		CALL `pa_categoria_insert`('nuevo2', @id_generado);

		-- consultamos la variable con una SELECT, no podemos hacer syso
		SELECT @id_generado;

		SELECT * FROM categoria;




- Procedimientos Almacenados
- Script Base Datos 'Gestion Docentes' con Procedimientos Almacenados
- Ejemplo Procedimiento Almacenado Oracle desde Java --> https://www.mkyong.com/jdbc/jdbc-callablestatement-stored-procedure-out-parameter-example/
	String runSP = "{ call get_employee_by_id(?,?,?,?) }";   --> 4 parámetros (?)

        try (Connection conn = DriverManager.getConnection(
                "jdbc:oracle:thin:@localhost:1521:orcl", "system", "Password123");
             Statement statement = conn.createStatement();
             CallableStatement callableStatement = conn.prepareCall(runSP)) {

            // create or replace stored procedure
            statement.execute(createSP);

            callableStatement.setInt(1, 3); --> 1er parámetro con valor 3

            callableStatement.registerOutParameter(2, java.sql.Types.VARCHAR); --> como todavía no sabemos el valor del parámetro, le pasamos su tipo
            callableStatement.registerOutParameter(3, Types.DECIMAL);
            callableStatement.registerOutParameter(4, java.sql.Types.DATE);

-------------------------------------------------------------------


09/01/2020:

- Funciones
	- funciones
	- Funciones Deterministas o no
		- AVG: hace la media
		- determinista si siempre devuelve lo mismo
		- Uso de las variables en funciones
		- Ejercicio practico fechas
			- google: mysql datetime functions --> https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html
								https://dev.mysql.com/doc/refman/5.7/en/case.html
				- @@lc_time_names --> lc es local
				- MONTHNAME() devuelve el nombre del mes en inglés por defecto, NOW() (devuelve la fecha hasta ms), CURDATE(), DIFDATE() da la diferencia entre 2 fechas


- Triggers - disparadores
	- se invocan cuando hacemos INSERT, UPDATE y DELETE antes AFTER o después BEFORE del evento.
	- Nomenclatura: empiezan por t --> tub: trigger update before (1 trigger, 2 acción (INSERT, UPDATE y DELETE), 3 cuándo lanza el trigger(AFTER o BEFORE))
	- sería mejor hacer el trigger en la base de datos porque puede haber más de una aplicaicón accediendo a ella y evitamos repetir código
	
	- Ejemplo de un trigger MySQL:

	A continuación definiremos el trigger. Se ejecutará antes de cada sentencia INSERT para la tabla people:
	mysql> delimiter //
	mysql> CREATE TRIGGER agecheck BEFORE INSERT ON people FOR EACH ROW IF NEW.age < 0 THEN SET NEW.age = 0; END IF;//
	Query OK, 0 rows affected (0.00 sec)
	mysql> delimiter ;

	comprobamos el parámetro nuevo NEW.age antes de insertarlo en la tabla para coprobar que no sea erróneo

	- OLD y NEW


-------------------------------------------------------------------


14/01/2020:

- Apache Tomcat 8
	- apache tomcat para servelts y jsps
	- versiones: tomcat 8.5, java 1.8 y servlets 3.0.1 (se ve en el pom), jsps 2.2 , versión aplicación 3.0 (ver el web.xml)
		<!-- variables comunes para todo el POM -->
		<properties>
			<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
			<java-version>1.8</java-version>
			<junit.version>4.12</junit.version>
			<javax.servlet.api>3.0.1</javax.servlet.api>
			<javax.servlet.jsp.version>2.2</javax.servlet.jsp.version>
			<javax.servlet.jstl.version>1.2</javax.servlet.jstl.version>
		</properties>

		<!-- web.xml -->
		<web-app xmlns="http://java.sun.com/xml/ns/javaee"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
			http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
			version="3.0">

	- carpetas 
		- bin 
			- arranque, cierre, y otros scripts y ejecutables --> C:\0396\apache-tomcat-8.5.47\bin
			- service.bat --> se puede programar para que se incicie el servicio de tomcat al arrancar en el ordenador
		- lib
			- .jar son las librerías

			con scope podemos tener varias opcones, por ej, provided:
			<!-- Web Project 3.0 -->
			<dependency>
				<groupId>javax.servlet</groupId>
				<artifactId>javax.servlet-api</artifactId>
				<version>${javax.servlet.api}</version>
				<scope>provided</scope>  <!-- Nos lo provee el servidor de aplicaciones -->
			</dependency>

			<dependency>
				<groupId>javax.servlet.jsp</groupId>
				<artifactId>jsp-api</artifactId>
				<version>		${javax.servlet.jsp.version}</version>
				<scope>provided</scope>
			</dependency>

		- pom : ficheros de config

	- Habilitar usuario administrador

		<?xml version='1.0' encoding='utf-8'?>
		<tomcat-users>
		<role rolename="manager"/>
		<role rolename="admin"/>
		<user username="tomcat" password="tomcat" roles="admin,manager"/>
		</tomcat-users>

		en nuestro servidor de producción: http://192.168.0.58:8080 --> http://192.168.0.58:8080/manager/html (manager para levantar y tirar las aplicaiones)


	- Abrir Tomcat para poder acceder desde otra IP
		Comentar la siguiente linea:
  		<Valve className="org.apache.catalina.valves.RemoteAddrValve"
         	allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" />

	- documentación de tomcat dentro del proyecto: http://192.168.0.58:8080/docs/



- Para subir a producción:
	- exportamos nuestra bd de heidi y renombramos como supermercado_AnaCristian el supermercado_grupo para ejecutarla como consulta en el servidor
	- exportar proyecto eclipse como war file
		si al exportar seleccionamos export source files también exporta los .java pero no hace falta		
		los controladores y clases están en classes dentro de WEB-INF
	- http://192.168.0.58:8080/  --> http://192.168.0.58:8080/manager/html
		


-------------------------------------------------------------------


15/01/2020:

- Views - Vistas o Tablas Virtuales
	- sólo se hacen consultas, no modificaciones
	- la vista por debajo lanza una select
	- son como tablas vistuales: es como hacer una consulta y se guarda en una tabla "virtual"
	- Información mas detallada sobre vistas --> https://manuales.guebs.com/mysql-5.0/views.html :

La cláusula opcional ALGORITHM es una extensión de MySQL al SQL estándar. ALGORITHM puede tomar tres valores: MERGE, TEMPTABLE, o UNDEFINED. El algoritmo por defecto es UNDEFINED si no se encuentra presente la cláusula ALGORITHM. El algoritmo afecta la manera en que MySQL procesa la vista.

Para MERGE, el texto de una sentencia que haga referencia a la vista y la definición de la vista son mezclados de forma que parte de la definición de la vista reemplaza las partes correspondientes de la consulta.

Para TEMPTABLE, los resultados devueltos por la vista son colocados en una tabla temporal, la cual es luego utilizada para ejecutar la sentencia.
(es como una foto)

Para UNDEFINED, MySQL determina el algoritmo que utilizará. En ese caso se prefiere MERGE por sobre TEMPTABLE si es posible, ya que MERGE por lo general es más eficiente y porque la vista no puede ser actualizable si se emplea una tabla temporal.

Una razón para elegir explícitamente TEMPTABLE es que los bloqueos en tablas subyacentes pueden ser liberados despues que la tabla temporal fue creada, y antes de que sea usada para terminar el procesamiento de la sentencia. Esto podría resultar en una liberación del bloqueo más rápida que en el algoritmo MERGE, de modo que otros clientes que utilicen la vista no estarán bloqueados mucho tiempo.

https://dev.mysql.com/doc/refman/8.0/en/view-algorithms.html 


	- ver words "20200115 Consultas vistas Heidi" / Ana Consultas vistas Heidi (entregado)


	¿por qué un pa tiene delimiter y la vista no?
	porque el pa podría tener sentencias que ocasionasen errores y las vistas no


	usuario/password: desarrollador desarrollador



- Diferencias Where y Having
	- la diferencia fundamental entre WHERE y HAVING es la siguente: WHERE selecciona las filas a mostrar antes de que sean agrupadas o procesadas por una funcion de agregacion, mientras HAVING selecciona las filas despues de que estas hayan sido procesadas o computadas, por lo tanto, la clausula WHERE no debe contener funciones de agrupacion o agregacion, mientras que la clausula HAVING siempre contiene funciones de agregacion, es permitido escribir clausulas HAVING que no contengan agrupacion
	- Funciones de agregación
		Las funciones de agregación en SQL nos permiten efectuar operaciones sobre un conjunto de resultados, pero devolviendo un único valor agregado para todos ellos. Es decir, nos permiten obtener medias, máximos, etc... sobre un conjunto de valores.

	- grupo by --> https://stackoverflow.com/questions/47903247/mysql-group-by-non-aggregate-column



CRUD_productos_y_usuarios_roles_seguridad_en_ProductoDAO_byUser