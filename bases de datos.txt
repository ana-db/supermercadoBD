MF0966_3 - Consulta y manipulación de información contenida en gestores de datos


26/12/2019:
	- java 7 Autoclosable
		- intro
		- Antes de Java 7
		- Uso del ARM

	- Pool de conexiones
		se encarga de gestionar todas las conexiones a la base de datos, en lugar de estar estableciendo la conexión y errándola cada vez que queramos acceder
		- intro
		- problemas
		- pool de cxs
		- config (en connectionManager): DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/mydb"); //jdbc/mydb --> devuelve un dataSource


	- JDBC Presentación (power point)


-------------------------------------------------------------------


27/12/2019:

- ACID
	- Atomicidad: o se hacen todos los pasos o ninguno (si se saca dinero del banco para ingresar en otra cuenta y no se lleva a cabo, no se quedan las 2 cuentas sin el dinero). Commit y rollback
	- Consistencia: los datos no cambian
	- Aislamiento: una operación no puede afectar a otras. Dos personas no pueden modificar a la vez el mismo registro de la bd (SGBD: sistemas gestión bases de datos)
	- Durabilidad: la info no se pierde aunque se apague el ordenador


- Motores de almacenamiento de MySQL y tipos de tablas
	- INNODB y MyISAM son las más usadas


-------------------------------------------------------------------


30/12/2019:

- JOINs combinar varias tablas
	- normalmente usamos inner join
	- RIGHT muestra aunque no tenga viviendas // LEFT es como la inner normal (posible test)
	- Equi-join --> 
		SELECT *
 		FROM   empleado
        	INNER JOIN departamento ON empleado.IDDepartamento = departamento.IDDepartamento
	- Natural join: no vamos a usar

	- Combinación externa (OUTER JOIN)
		- LEFT (dando la vuelta a las tablas una right se puede convertir en una left)
		- LEFT JOIN excluyendo la intersección

- Normalización de un Base de Datos (pdf)
	- "...en el código PHP ...  preparado para comenzar a desarrollar tu aplicación en PHP (sustituir php por java)"
	- BD relacional: tablas que se relacionan entre otras y se pueden sacar datos relacionados de varias
	- quitar duplicados --> conseguimos consistencia
	- Primer nivel de Formalización/Normalización. (F/N)
		1. Eliminar los grupos repetitivos de la tablas individuales.
		2. Crear una tabla separada por cada grupo de datos relacionados.
		3. Identificar cada grupo de datos relacionados con una clave primaria. 
	- Segundo nivel de F/N (tabla auxiliar)
		1. Crear tablas separadas para aquellos grupos de datos que se aplican a varios registros.
		2. Relacionar estas tablas mediante una clave externa. 
	- Tercer nivel de F/N.
		1. Eliminar aquellos campos que no dependan de la clave. --> toda info redundante la sacamos a otra tabla
	- Cuarto Nivel de F/N.
		1. En las relaciones varios-con-varios, entidades independientes no pueden ser almacenadas en la misma tabla. 
		--> si la relación es N a N, sacamos una tabla nueva
	- Quinto Nivel de F/N
		1. La tabla original debe ser reconstruida desde las tablas resultantes en las cuales ha sido troceada. 

- Hacemos un test de 20 preguntas con lo que hemos dado hasta aquí


-------------------------------------------------------------------


08/01/2020:


- Procedimientos almacenados. Procedimientos y Funciones
	- creamos tabla categorías y procedimiento con Heidi


		CONSULTA INSERT HEIDI
		-- declaramos una variable usando @
		SET @id_generado = 0;

		-- llamamos al procedimiento almacenado
		CALL `pa_categoria_insert`('nuevo2', @id_generado);

		-- consultamos la variable con una SELECT, no podemos hacer syso
		SELECT @id_generado;

		SELECT * FROM categoria;




- Procedimientos Almacenados
- Script Base Datos 'Gestion Docentes' con Procedimientos Almacenados
- Ejemplo Procedimiento Almacenado Oracle desde Java --> https://www.mkyong.com/jdbc/jdbc-callablestatement-stored-procedure-out-parameter-example/
	String runSP = "{ call get_employee_by_id(?,?,?,?) }";   --> 4 parámetros (?)

        try (Connection conn = DriverManager.getConnection(
                "jdbc:oracle:thin:@localhost:1521:orcl", "system", "Password123");
             Statement statement = conn.createStatement();
             CallableStatement callableStatement = conn.prepareCall(runSP)) {

            // create or replace stored procedure
            statement.execute(createSP);

            callableStatement.setInt(1, 3); --> 1er parámetro con valor 3

            callableStatement.registerOutParameter(2, java.sql.Types.VARCHAR); --> como todavía no sabemos el valor del parámetro, le pasamos su tipo
            callableStatement.registerOutParameter(3, Types.DECIMAL);
            callableStatement.registerOutParameter(4, java.sql.Types.DATE);

-------------------------------------------------------------------


09/01/2020:

- Funciones
	- funciones
	- Funciones Deterministas o no
		- AVG: hace la media
		- determinista si siempre devuelve lo mismo
		- Uso de las variables en funciones
		- Ejercicio practico fechas
			- google: mysql datetime functions --> https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html
								https://dev.mysql.com/doc/refman/5.7/en/case.html
				- @@lc_time_names --> lc es local
				- MONTHNAME() devuelve el nombre del mes en inglés por defecto, NOW() (devuelve la fecha hasta ms), CURDATE(), DIFDATE() da la diferencia entre 2 fechas


- Triggers - disparadores
	- se invocan cuando hacemos INSERT, UPDATE y DELETE antes AFTER o después BEFORE del evento.
	- Nomenclatura: empiezan por t --> tub: trigger update before (1 trigger, 2 acción (INSERT, UPDATE y DELETE), 3 cuándo lanza el trigger(AFTER o BEFORE))
	- sería mejor hacer el trigger en la base de datos porque puede haber más de una aplicaicón accediendo a ella y evitamos repetir código
	
	- Ejemplo de un trigger MySQL:

	A continuación definiremos el trigger. Se ejecutará antes de cada sentencia INSERT para la tabla people:
	mysql> delimiter //
	mysql> CREATE TRIGGER agecheck BEFORE INSERT ON people FOR EACH ROW IF NEW.age < 0 THEN SET NEW.age = 0; END IF;//
	Query OK, 0 rows affected (0.00 sec)
	mysql> delimiter ;

	comprobamos el parámetro nuevo NEW.age antes de insertarlo en la tabla para coprobar que no sea erróneo

	- OLD y NEW








CRUD_productos_y_usuarios_roles_seguridad_en_ProductoDAO_byUser